import { Address, BigInt, Bytes, ethereum } from "@graphprotocol/graph-ts";
import { PairFactory } from "../generated/templates/PairReader/PairFactory";
import { ERC20 } from "../generated/templates/PairReader/ERC20";
import { Swap } from "../generated/templates/PairReader/Pair";

import {
  ZERO_ADDRESS,
  addAccumulativeTokenBalance,
  getOrCreateGeneratedVolume,
  createReferral,
  createSwapLog,
  getDIBS as getDibs,
  getOrCreateLottery,
  getOrCreateUserLottery,
  getDIBSLottery as getDibsLottery,
  getBNBChainLink as getWethPriceFeed,
  updateVolume,
  VolumeType,
  getRewardPercentage,
  getNumberOfTickets,
  getOrCreateWeeklyGeneratedVolume,
  getFactory,
  WETH,
} from "./utils";
import { Pair } from "../generated/templates/PairReader/Pair";
import {
  PathToTarget,
  TotalVolumeTracker,
  DailyVolumeTracker,
} from "../generated/schema";
import { EACAggregatorProxy } from "../generated/templates/PairReader/EACAggregatorProxy";
import { Dibs } from "../generated/templates/PairReader/Dibs";
import { DibsLottery } from "../generated/templates/PairReader/DibsLottery";

export class SwapHandler {
  event: Swap;
  pair: Pair;
  pairFactory: PairFactory;
  dibs: Dibs;
  dibsLottery: DibsLottery;
  priceFeed: EACAggregatorProxy;
  token0: Address;
  amountIn0: BigInt;
  token1: Address;
  amountIn1: BigInt;
  timestamp: BigInt;

  user: Address;
  parent: Address;
  grandParent: Address;

  constructor(event: Swap) {
    const dibs = getDibs();
    const pair = Pair.bind(event.address);

    const user = event.transaction.from;
    const parent = dibs.parents(user);
    let grandParent = dibs.parents(parent);

    this.event = event;
    this.pair = pair;
    this.dibs = dibs;
    this.dibsLottery = getDibsLottery();
    this.priceFeed = getWethPriceFeed();
    this.pairFactory = getFactory();
    this.token0 = pair.token0();
    this.token1 = pair.token1();
    this.amountIn0 = event.params.amount0In;
    this.amountIn1 = event.params.amount1In;

    this.timestamp = event.block.timestamp;

    this.user = user;
    this.parent = parent;

    // if the grandparent address is address 0x0, set grandparent address to dibs address
    if (grandParent == ZERO_ADDRESS) {
      grandParent = dibs.codeToAddress(dibs.DIBS());
    }

    this.grandParent = grandParent;
  }

  public handle(): void {
    this._handle0();
    this._handle1();
  }

  private _handle0(): void {
    if (this.amountIn0.gt(BigInt.fromI32(0)))
      this._handle(this.token0, this.amountIn0);
  }

  private _handle1(): void {
    if (this.amountIn1.gt(BigInt.fromI32(0)))
      this._handle(this.token1, this.amountIn1);
  }

  private _handle(token: Address, amountIn: BigInt): void {
    const volumeInWeth = this._getVolumeInWeth(token, amountIn);
    const volumeInDollars = this._getVolumeInDollars(volumeInWeth);

    this._updateTotalVolume(volumeInDollars); // track total volume generated by the platform

    if (this._isRegisteredUser()) {
      this._updateDibsVolume(volumeInDollars); // track total volume generated through dibs platform
      this._updateGeneratedVolumes(volumeInDollars); // track total volume generated by user, parent and grandparent
      this._distributeRewards(amountIn, token);
      this._distributeLotteryTickets();
      createReferral(this.parent, this.user);
      this._createSwapLog(amountIn, token);
    }
  }

  private _createSwapLog(amountIn: BigInt, token: Address): void {
    const volumeInWeth = this._getVolumeInWeth(token, amountIn);
    const volumeInDollars = this._getVolumeInDollars(volumeInWeth);

    createSwapLog(
      this.event,
      this.user,
      token,
      amountIn,
      this.pair.isStable(),
      this.dibsLottery.getActiveLotteryRound(),
      volumeInWeth,
      this.priceFeed.latestAnswer(),
      volumeInDollars
    );
  }

  private _getVolumeInWeth(token: Address, amount: BigInt): BigInt {
    let volumeInWeth: BigInt;
    const inputToken = ERC20.bind(token);
    const precision = 4;

    if (token == WETH) {
      // if input token is wETH, no need to make conversions
      volumeInWeth = amount;
    } else {
      // in case input token is not wETH
      const unit = BigInt.fromI32(10).pow(
        u8(inputToken.decimals() - precision)
      );
      let unitVolumeInWeth: BigInt;
      const pathToWeth = PathToTarget.load(token.toHex() + "-" + WETH.toHex());

      if (pathToWeth == null) {
        // no route to wETH
        unitVolumeInWeth = BigInt.fromI32(0);
      } else {
        let _unit = unit;
        let _token = token;

        for (let i = 0; i < pathToWeth.path.length; i++) {
          const _pair = Pair.bind(Address.fromBytes(pathToWeth.path[i]));
          _unit = _pair.getAmountOut(_unit, _token);
          _token = token == _pair.token0() ? _pair.token1() : _pair.token0();
        }
        unitVolumeInWeth = _unit;
      }

      volumeInWeth = unitVolumeInWeth.times(amount).div(unit); // time the amount of input token
    }
    return volumeInWeth;
  }

  private _getVolumeInDollars(volumeInWeth: BigInt): BigInt {
    return this.priceFeed
      .latestAnswer()
      .times(volumeInWeth)
      .div(BigInt.fromI32(10).pow(u8(this.priceFeed.decimals())));
  }

  private _updateTotalVolume(volumeInDollars: BigInt): void {
    const totalVolumeTracker = this._getTotalVolumeTracker();
    totalVolumeTracker.totalVolume = totalVolumeTracker.totalVolume.plus(
      volumeInDollars
    );

    // update daily volume
    const dailyVolumeTracker = this._getDailyVolumeTracker();

    dailyVolumeTracker.totalVolume = dailyVolumeTracker.totalVolume.plus(
      volumeInDollars
    );

    totalVolumeTracker.save();
    dailyVolumeTracker.save();
  }

  private _getTotalVolumeTracker(): TotalVolumeTracker {
    let tracker = TotalVolumeTracker.load("0");

    if (tracker == null) {
      tracker = new TotalVolumeTracker("0");
      tracker.totalVolume = BigInt.fromI32(0);
      tracker.dibsVolume = BigInt.fromI32(0);
      tracker.save();
    }

    return tracker as TotalVolumeTracker;
  }

  private _getDailyVolumeTracker(): DailyVolumeTracker {
    const day = this.event.block.timestamp
      .div(BigInt.fromI32(86400))
      .times(BigInt.fromI32(86400));

    let tracker = DailyVolumeTracker.load(day.toString());

    if (tracker == null) {
      tracker = new DailyVolumeTracker(day.toString());
      tracker.totalVolume = BigInt.fromI32(0);
      tracker.dibsVolume = BigInt.fromI32(0);
      tracker.day = day;
      tracker.save();
    }

    return tracker as DailyVolumeTracker;
  }

  private _updateDibsVolume(volumeInDollars: BigInt): void {
    const totalVolumeTracker = this._getTotalVolumeTracker();
    const dailyVolumeTracker = this._getDailyVolumeTracker();

    totalVolumeTracker.dibsVolume = totalVolumeTracker.dibsVolume.plus(
      volumeInDollars
    );

    dailyVolumeTracker.dibsVolume = dailyVolumeTracker.dibsVolume.plus(
      volumeInDollars
    );

    totalVolumeTracker.save();
    dailyVolumeTracker.save();
  }

  private _updateGeneratedVolumes(volumeInDollars: BigInt): void {
    updateVolume(this.user, volumeInDollars, this.timestamp, VolumeType.USER);
    updateVolume(
      this.parent,
      volumeInDollars,
      this.timestamp,
      VolumeType.PARENT
    );
    updateVolume(
      this.grandParent,
      volumeInDollars,
      this.timestamp,
      VolumeType.GRANDPARENT
    );
  }

  private _getRewardAmount(amount: BigInt): BigInt {
    const feeRate = this.pairFactory.getFee(this.pair.isStable());
    const feeAmount = amount.times(feeRate).div(BigInt.fromI32(10000));
    const rewardPercentage = getRewardPercentage(
      getOrCreateGeneratedVolume(this.parent).amountAsReferrer
    );
    const rewardAmount = feeAmount
      .times(rewardPercentage)
      .div(BigInt.fromI32(10000));
    return rewardAmount;
  }

  private _distributeRewards(totalAmount: BigInt, token: Address): void {
    const rewardAmount = this._getRewardAmount(totalAmount);
    const scale = this.dibs.SCALE();
    const grandParentPercentage = this.dibs.grandparentPercentage();
    const dibsPercentage = this.dibs.dibsPercentage();
    const grandParentAmount = rewardAmount
      .times(grandParentPercentage)
      .div(scale);
    const dibsAmount = rewardAmount.times(dibsPercentage).div(scale);
    const parentAmount = rewardAmount.minus(grandParentAmount.plus(dibsAmount));

    // add the reward amount to the accumulative token balance for the parent, grandparent and dibs platform
    addAccumulativeTokenBalance(
      token,
      this.parent,
      parentAmount,
      this.timestamp
    );
    addAccumulativeTokenBalance(
      token,
      this.grandParent,
      grandParentAmount,
      this.timestamp
    );
    addAccumulativeTokenBalance(
      token,
      this.dibs.codeToAddress(this.dibs.DIBS()),
      dibsAmount,
      this.timestamp
    );
  }

  private _distributeLotteryTickets(): void {
    const round = this.dibsLottery.getActiveLotteryRound();
    const lottery = getOrCreateLottery(round);
    const userLottery = getOrCreateUserLottery(round, this.user);
    const tickets = getNumberOfTickets(
      getOrCreateWeeklyGeneratedVolume(this.user, round).amountAsUser
    );

    const addedTickets = tickets.minus(userLottery.tickets);

    if (addedTickets.gt(BigInt.fromI32(0))) {
      userLottery.tickets = tickets;
      lottery.totalTikets = lottery.totalTikets.plus(addedTickets);
      userLottery.save();
      lottery.save();
    }
  }

  private _isRegisteredUser(): boolean {
    // all registered users must have a non-zero parent
    return this.parent != ZERO_ADDRESS;
  }
}

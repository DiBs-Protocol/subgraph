import { Address, BigInt, Bytes, ethereum } from "@graphprotocol/graph-ts";
import { PairFactory } from "../generated/templates/PairReader/PairFactory";
import { ERC20 } from "../generated/templates/PairReader/ERC20";
import { Swap } from "../generated/templates/PairReader/Pair";

import {
  ZERO_ADDRESS,
  addAccumulativeTokenBalance,
  getOrCreateGeneratedVolume,
  createReferral,
  createSwapLog,
  getDIBS as getDibs,
  getOrCreateLottery,
  getOrCreateUserLottery,
  getDIBSLottery as getDibsLottery,
  getBNBChainLink as getWethPriceFeed,
  updateVolume,
  VolumeType,
  getRewardPercentage,
  getNumberOfTickets,
  getOrCreateWeeklyGeneratedVolume,
  getFactory,
  WETH,
} from "./utils";
import { Pair } from "../generated/templates/PairReader/Pair";
import {
  PathToTarget,
  TotalVolumeTracker,
  DailyVolumeTracker,
} from "../generated/schema";
import { EACAggregatorProxy } from "../generated/templates/PairReader/EACAggregatorProxy";
import { Dibs } from "../generated/templates/PairReader/Dibs";
import { DibsLottery } from "../generated/templates/PairReader/DibsLottery";

class SwapHandler {
  event: Swap;
  pair: Pair;
  pairFactory: PairFactory;
  dibs: Dibs;
  dibsLottery: DibsLottery;
  priceFeed: EACAggregatorProxy;
  token0: Address;
  amountIn0: BigInt;
  token1: Address;
  amountIn1: BigInt;
  timestamp: BigInt;

  totalVolumeTracker: TotalVolumeTracker;
  dailyVolumeTracker: DailyVolumeTracker;

  user: Address;
  parent: Address;
  grandParent: Address;

  constructor(event: Swap) {
    this.event = event;
    this.pair = Pair.bind(event.address);
    this.pairFactory = getFactory();
    this.dibs = getDibs();
    this.dibsLottery = getDibsLottery();
    this.priceFeed = getWethPriceFeed();

    this.token0 = this.pair.token0();
    this.token1 = this.pair.token1();
    this.amountIn0 = event.params.amount0In;
    this.amountIn1 = event.params.amount1In;

    this.timestamp = event.block.timestamp;

    this.totalVolumeTracker = this._getTotalVolumeTracker();
    this.dailyVolumeTracker = this._getDailyVolumeTracker();

    this.user = event.transaction.from;
    this.parent = this.dibs.parents(this.user);
    this.grandParent = this.dibs.parents(this.parent);

    // if the grandparent address is address 0x0, set grandparent address to dibs address
    if (this.grandParent == ZERO_ADDRESS) {
      this.grandParent = this.dibs.codeToAddress(this.dibs.DIBS());
    }
  }

  public handle0(): void {
    if (this.amountIn0.gt(BigInt.fromI32(0)))
      this._handle(this.token0, this.amountIn0);
  }

  public handle1(): void {
    if (this.amountIn1.gt(BigInt.fromI32(0)))
      this._handle(this.token1, this.amountIn1);
  }

  private _handle(token: Address, amountIn: BigInt): void {
    const volumeInWeth = this._getVolumeInWeth(token, amountIn);
    const volumeInDollars = this._getVolumeInDollars(volumeInWeth);

    this._updateTotalVolume(volumeInDollars); // track total volume generated by the platform

    if (this._isRegisteredUser()) {
      this._updateDibsVolume(volumeInDollars); // track total volume generated through dibs platform
      this._updateGeneratedVolumes(volumeInDollars); // track total volume generated by user, parent and grandparent
      this._distributeRewards(token, amountIn);
    }
  }

  private _getVolumeInWeth(token: Address, amount: BigInt): BigInt {
    let volumeInWeth: BigInt;
    const inputToken = ERC20.bind(token);
    const precision = 4;

    if (token == WETH) {
      // if input token is wETH, no need to make conversions
      volumeInWeth = amount;
    } else {
      // in case input token is not wETH
      const unit = BigInt.fromI32(10).pow(
        u8(inputToken.decimals() - precision)
      );
      let unitVolumeInWeth: BigInt;
      const pathToWeth = PathToTarget.load(token.toHex() + "-" + WETH.toHex());

      if (pathToWeth == null) {
        // no route to wETH
        unitVolumeInWeth = BigInt.fromI32(0);
      } else {
        let _unit = unit;
        let _token = token;

        for (let i = 0; i < pathToWeth.path.length; i++) {
          const _pair = Pair.bind(Address.fromBytes(pathToWeth.path[i]));
          _unit = _pair.getAmountOut(_unit, _token);
          _token = token == _pair.token0() ? _pair.token1() : _pair.token0();
        }
        unitVolumeInWeth = _unit;
      }

      volumeInWeth = unitVolumeInWeth.times(amount).div(unit); // time the amount of input token
    }
    return volumeInWeth;
  }

  private _getVolumeInDollars(volumeInWeth: BigInt): BigInt {
    return this.priceFeed
      .latestAnswer()
      .times(volumeInWeth)
      .div(BigInt.fromI32(10).pow(u8(this.priceFeed.decimals())));
  }

  private _updateTotalVolume(volumeInDollars: BigInt): void {
    const totalVolumeTracker = this.totalVolumeTracker;
    totalVolumeTracker.totalVolume = totalVolumeTracker.totalVolume.plus(
      volumeInDollars
    );

    // update daily volume
    const dailyVolumeTracker = this.dailyVolumeTracker;

    dailyVolumeTracker.totalVolume = dailyVolumeTracker.totalVolume.plus(
      volumeInDollars
    );

    totalVolumeTracker.save();
    dailyVolumeTracker.save();
  }

  private _getTotalVolumeTracker(): TotalVolumeTracker {
    let tracker = TotalVolumeTracker.load("0");

    if (tracker == null) {
      tracker = new TotalVolumeTracker("0");
      tracker.totalVolume = BigInt.fromI32(0);
      tracker.dibsVolume = BigInt.fromI32(0);
      tracker.save();
    }

    return tracker as TotalVolumeTracker;
  }

  private _getDailyVolumeTracker(): DailyVolumeTracker {
    const day = this.event.block.timestamp
      .div(BigInt.fromI32(86400))
      .times(BigInt.fromI32(86400));

    let tracker = DailyVolumeTracker.load(day.toString());

    if (tracker == null) {
      tracker = new DailyVolumeTracker(day.toString());
      tracker.totalVolume = BigInt.fromI32(0);
      tracker.dibsVolume = BigInt.fromI32(0);
      tracker.day = day;
      tracker.save();
    }

    return tracker as DailyVolumeTracker;
  }

  private _updateDibsVolume(volumeInDollars: BigInt): void {
    const totalVolumeTracker = this.totalVolumeTracker;
    const dailyVolumeTracker = this.dailyVolumeTracker;

    totalVolumeTracker.dibsVolume = totalVolumeTracker.dibsVolume.plus(
      volumeInDollars
    );

    dailyVolumeTracker.dibsVolume = dailyVolumeTracker.dibsVolume.plus(
      volumeInDollars
    );

    totalVolumeTracker.save();
    dailyVolumeTracker.save();
  }

  private _updateGeneratedVolumes(volumeInDollars: BigInt): void {
    updateVolume(this.user, volumeInDollars, this.timestamp, VolumeType.USER);
    updateVolume(
      this.parent,
      volumeInDollars,
      this.timestamp,
      VolumeType.PARENT
    );
    updateVolume(
      this.grandParent,
      volumeInDollars,
      this.timestamp,
      VolumeType.GRANDPARENT
    );
  }

  private _isRegisteredUser(): boolean {
    // all registered users must have a non-zero parent
    return this.parent != ZERO_ADDRESS;
  }
}

export function handleSwap(event: Swap): void {
  if (event.block.number.lt(BigInt.fromI64(25238657))) {
    return;
  }
  const handler = new SwapHandler(event);
  handler.handle0();
  handler.handle1();
}

function _handleSwap(
  event: Swap,
  token: Address,
  amount: BigInt,
  user: Address,
  timestamp: BigInt
): void {
  const dibs = getDibs();
  const inputToken = ERC20.bind(token);
  const dibsLottery = getDibsLottery();
  const pairFactory = getFactory();
  const pair = Pair.bind(event.address);
  const priceFeed = getWethPriceFeed();

  // calculate total amount of reward based on MAX_REFERRAL_FEE from pairFactory
  let rewardAmount = getTotalRewardGenerated(
    pairFactory,
    pair,
    amount,
    parentAddress
  );

  // calculate the amount of tokens that the parent and grandparent and dibs platform will receive
  distributeRewards(
    dibs,
    rewardAmount,
    token,
    parentAddress,
    timestamp,
    grandParentAddress
  );

  const round = dibsLottery.getActiveLotteryRound();

  // create a referral if it does not exist
  createReferral(parentAddress, user);
  createSwapLog(
    event,
    user,
    token,
    amount,
    pair.isStable(),
    round,
    volumeInWeth,
    wethPrice,
    volumeInDollars
  );

  const lottery = getOrCreateLottery(round);
  const userLottery = getOrCreateUserLottery(round, user);
  const tickets = getNumberOfTickets(
    getOrCreateWeeklyGeneratedVolume(user, round).amountAsUser
  );

  const addedTickets = tickets.minus(userLottery.tickets);

  if (addedTickets.gt(BigInt.fromI32(0))) {
    userLottery.tickets = tickets;
    lottery.totalTikets = lottery.totalTikets.plus(addedTickets);
    userLottery.save();
    lottery.save();
  }
}

function distributeRewards(
  dibs: Dibs,
  rewardAmount: BigInt,
  token: Address,
  parentAddress: Address,
  timestamp: BigInt,
  grandParentAddress: Address
): void {
  const scale = dibs.SCALE();
  const grandParentPercentage = dibs.grandparentPercentage();
  const dibsPercentage = dibs.dibsPercentage();
  const grandParentAmount = rewardAmount
    .times(grandParentPercentage)
    .div(scale);
  const dibsAmount = rewardAmount.times(dibsPercentage).div(scale);
  const parentAmount = rewardAmount.minus(grandParentAmount.plus(dibsAmount));

  // add the reward amount to the accumulative token balance for the parent, grandparent and dibs platform
  updateAccumulativeBalances(
    token,
    parentAddress,
    parentAmount,
    timestamp,
    grandParentAddress,
    grandParentAmount,
    dibs,
    dibsAmount
  );
}

function updateAccumulativeBalances(
  token: Address,
  parentAddress: Address,
  parentAmount: BigInt,
  timestamp: BigInt,
  grandParentAddress: Address,
  grandParentAmount: BigInt,
  dibs: Dibs,
  dibsAmount: BigInt
): void {
  addAccumulativeTokenBalance(token, parentAddress, parentAmount, timestamp);
  addAccumulativeTokenBalance(
    token,
    grandParentAddress,
    grandParentAmount,
    timestamp
  );
  addAccumulativeTokenBalance(
    token,
    dibs.codeToAddress(dibs.DIBS()),
    dibsAmount,
    timestamp
  );
}

function getTotalRewardGenerated(
  pairFactory: PairFactory,
  pair: Pair,
  amount: BigInt,
  parentAddress: Address
): BigInt {
  let feeRate = pairFactory.getFee(pair.isStable());
  let feeAmount = amount.times(feeRate).div(BigInt.fromI32(10000));
  let rewardPercentage = getRewardPercentage(
    getOrCreateGeneratedVolume(parentAddress).amountAsReferrer
  );
  let rewardAmount = feeAmount
    .times(rewardPercentage)
    .div(BigInt.fromI32(10000));
  return rewardAmount;
}
